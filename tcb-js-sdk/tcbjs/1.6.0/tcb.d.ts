// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@cloudbase/database
//   ../@cloudbase/adapter-interface

import { Db } from '@cloudbase/database';
import { SDKAdapterInterface, CloudbaseAdapter } from '@cloudbase/adapter-interface';
import { IRequestOptions, SDKRequestInterface, ResponseObject, IUploadRequestOptions } from '@cloudbase/adapter-interface';

interface ICloudbaseConfig {
    env: string;
    timeout?: number;
    persistence?: string;
    adapter?: SDKAdapterInterface;
    appSecret?: AppSecret;
    appSign?: string;
}
type Persistence = 'local' | 'session' | 'none';
class TCB {
    config: ICloudbaseConfig;
    authObj: Auth;
    requestClient: any;
    constructor(config?: ICloudbaseConfig);
    init(config: ICloudbaseConfig): TCB;
    database(dbConfig?: object): Db;
    auth({ persistence }?: {
        persistence?: Persistence;
    }): Auth;
    on(eventName: string, callback: Function): void;
    off(eventName: string, callback: Function): void;
    callFunction(params: {
        name: string;
        data: any;
        query: any;
        parse: boolean;
    }, callback?: Function): any;
    deleteFile(params: {
        fileList: string[];
    }, callback?: Function): any;
    getTempFileURL(params: {
        fileList: string[];
    }, callback?: Function): any;
    downloadFile(params: {
        fileID: string;
    }, callback?: Function): Promise<any>;
    uploadFile(params: {
        cloudPath: string;
        filePath: File;
        onUploadProgress?: Function;
    }, callback?: Function): any;
    getUploadMetadata(params: {
        cloudPath: string;
        ci?: Object;
    }, callback?: Function): any;
    registerExtension(ext: any): void;
    invokeExtension(name: any, opts: any): Promise<any>;
    useAdapters(adapters: CloudbaseAdapter | CloudbaseAdapter[]): void;
}
const tcb: TCB;
export = tcb;

export interface UserInfo {
    openid: string;
    nickname?: string;
    sex?: number;
    province?: string;
    city?: string;
    country?: string;
    headimgurl?: string;
    privilege?: [string];
    unionid?: string;
}
export class Auth {
    constructor(config: Config);
    get loginType(): LOGINTYPE;
    weixinAuthProvider({ appid, scope, state }: {
        appid: any;
        scope: any;
        state: any;
    }): WeixinAuthProvider;
    anonymousAuthProvider(): AnonymousAuthProvider;
    customAuthProvider(): CustomAuthProvider;
    signInAnonymously(): Promise<{
        credential: {
            refreshToken: any;
        };
    }>;
    linkAndRetrieveDataWithTicket(ticket: string): Promise<{
        credential: {
            refreshToken: any;
        };
    }>;
    signOut(): Promise<any>;
    onLoginStateChanged(callback: Function): void;
    onLoginStateExpired(callback: Function): void;
    onAccessTokenRefreshed(callback: Function): void;
    onAnonymousConverted(callback: Function): void;
    onLoginTypeChanged(callback: Function): void;
    getAccessToken(): Promise<{
        accessToken: string;
        env: string;
    }>;
    hasLoginState(): LoginResult;
    getLoginState(): Promise<LoginResult>;
    signInWithTicket(ticket: string): Promise<LoginResult>;
    shouldRefreshAccessToken(hook: any): void;
    getUserInfo(): any;
    getAuthHeader(): {
        'x-cloudbase-credentials': string;
    };
}

export const SDK_VERISON: any;
export interface AppSecret {
    appAccessKeyId: string;
    appAccessKey: string;
}
export interface Config {
    env?: string;
    token?: string;
    timeout?: number;
    proxy?: string;
    persistence?: string;
    appSecret?: AppSecret;
    appSign?: string;
}
export type KV<T> = {
    [key: string]: T;
};
interface MetaData {
    url: string;
    token: string;
    authorization: string;
    fileId: string;
    cosFileId: string;
}
export interface MetaDataRes {
    data: MetaData;
    requestId: string;
}
export type LOGIN_TYPE = 'WECHAT-OPEN' | 'WECHAT-PUBLIC' | 'ANONYMOUS' | 'CUSTOM';
export const ACCESS_TOKEN = "access_token";
export const ACCESS_TOKEN_Expire = "access_token_expire";
export const REFRESH_TOKEN = "refresh_token";
export const ANONYMOUS_UUID = "anonymous_uuid";
export const LOGIN_TYPE_KEY = "login_type";
export const protocol: string;
export const BASE_URL: string;
export const dataVersion = "2020-01-10";
export {};

export class WeixinAuthProvider extends AuthProvider {
    config: Config;
    constructor(config: Config, appid: string, scope: string, state?: string);
    signInWithRedirect(): Promise<any>;
    getRedirectResult(): Promise<{
        credential: {
            refreshToken: string;
        };
    }>;
    signIn(): Promise<LoginResult>;
}

export class AnonymousAuthProvider extends AuthProvider {
    signIn(): Promise<{
        credential: {
            refreshToken: any;
        };
    }>;
    linkAndRetrieveDataWithTicket(ticket: string): Promise<{
        credential: {
            refreshToken: any;
        };
    }>;
}

export enum LOGINTYPE {
    ANONYMOUS = "ANONYMOUS",
    WECHAT = "WECHAT",
    CUSTOM = "CUSTOM",
    NULL = "NULL"
}
export class AuthProvider {
    config: Config;
    protected readonly _cache: ICache;
    protected readonly _request: IRequest;
    constructor(config: Config);
    protected setRefreshToken(refreshToken: any): void;
}

export interface LoginResult {
    isAnonymous?: boolean;
    credential: {
        refreshToken: string;
        accessToken?: string;
    };
}

export class CustomAuthProvider extends AuthProvider {
    signIn(ticket: string): Promise<LoginResult>;
}

interface GetAccessTokenResult {
    accessToken: string;
    accessTokenExpire: number;
}
export type CommonRequestOptions = {
    headers?: KV<string>;
    responseType?: string;
    onUploadProgress?: Function;
};
class IRequest {
    config: Config;
    _shouldRefreshAccessTokenHook: Function;
    _refreshAccessTokenPromise: Promise<GetAccessTokenResult> | null;
    _reqClass: SDKRequestInterface;
    constructor(config?: Config);
    post(options: IRequestOptions): Promise<ResponseObject>;
    upload(options: IUploadRequestOptions): Promise<ResponseObject>;
    download(options: IRequestOptions): Promise<ResponseObject>;
    refreshAccessToken(): Promise<GetAccessTokenResult>;
    _refreshAccessToken(): Promise<GetAccessTokenResult>;
    getAccessToken(): Promise<GetAccessTokenResult>;
    request(action: any, params: any, options?: any): Promise<any>;
    send(action: string, data?: any): Promise<any>;
}
function initRequest(config: Config): void;
function getRequestByEnvId(env: string): IRequest;
export { getRequestByEnvId, IRequest, initRequest };

export class ICache {
    keys: KV<string>;
    constructor(config: Config);
    updatePersistence(persistence: string): void;
    setStore(key: string, value: any, version?: any): void;
    getStore(key: string, version?: string): any;
    removeStore(key: any): void;
}
function initCache(config: Config): void;
function getCache(env: string): ICache;
function getLocalCache(env: string): ICache;
export { getCache, initCache, getLocalCache };

